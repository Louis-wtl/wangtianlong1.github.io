{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"vue07vuex使用","slug":"vue07vuex使用","date":"2019-12-26T18:56:31.677Z","updated":"2019-10-22T10:55:27.311Z","comments":true,"path":"2019/12/27/vue07vuex使用/","link":"","permalink":"http://yoursite.com/2019/12/27/vue07vuex%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Vue传参A页面-&gt;B页面页面和页面之间传参, A 跳转 B, 可以使用 router-link 在路由配置里, 配置好/:变量, 会对应解析路径中的值 $router.push path+query name+params 案例1: 在User页面向Pass页面传值, 再从Pass页面向Age页面传值, 再把值一起传给Confirm页面 A页面 &lt;- B页面使用history.back() 来用浏览器的机制返回上一页, 可以使用 cookie localStorage sessionStorage 页面 -&gt; 组件 props属性 页面 &lt;- 组件 自定义事件, 然后this.$emit(事件名) 组件 和 组件如果组件A 和 组件B 之间没有import 引用的关系, 而是在页面中 同时引入组件A 和 组件B 案例2: 颜色组件, 讲解页面-&gt;组件传值 (颜色文字和颜色英文), 点击颜色, 修改同级组件中标签颜色 EventBus简介使用一个独立全新的Vue对象, 无需根节点, 这个Vue对象, 只是负责整个项目的事件管理 使用 新建src/EventBus.js 新建全新的Vue对象 123 import Vue from 'vue' // 导出一个空白的Vue对象, 这个Vue对象无需根节点, 它只负责组件之间的通信export default new Vue() 接收的位置注册Bus事件 1Bus.$on(\"事件名\", 方法体); 触发传值的位置 触发对应的事件 1Bus.$emit(\"事件名\", 传递的参数对象) 注意: 可以有多个注册/触发的地方, 而且事件可以有多个不同的, 注意对应好 (释放) 在组件废弃, 放弃事件监听 12// Bus.$off('事件名'); // 移除所有事件名绑定的地方// Bus.$off('事件名', 方法体); // 移除当前事件绑定的地方 重点注意: 一定要让$on的代码先执行, 再执行$emit才可以触发事件 适用适用于项目不是特别大的情况下, 如果组件过多, 而且事件也过多, 则不利于维护和调试以及扩展 为什么使用Vuex: 因为当项目特别大的时候, 页面和组件过多, 那么你需要维护的自定义事件的名字也会特别多, 而且发送事件和接收事件的地方需要你记住进行维护, 会异常麻烦, 所以我们要把这些状态值提取到一个统一的地方, 那么由vuex模块, 来帮助我们进行维护 Vuex简介​ Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 案例3: 实现商品浏览+购买功能, 以及购物车展示功能 使用 在当前工程下载Vuex模块 $ npm install vuex –save 新建src/store/index.js, 引入Vuex模块, 确保Vue.use(Vuex) 让Vue集成Vuex的功能 然后实例化Vuex的Store仓库对象new Vuex.Store({}), 并向外暴露这个Store对象 在main.js入口中, 引入store文件, 注入到Vue实例中 到此, 我们vuex就已经成功集成到了Vue项目中 核心概念state(全局变量)​ 好比data, 定义变量的地方 ​ Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 实例: 1234state: &#123; shopCarArr: [1, 2, 3, 4] &#x2F;&#x2F; 用于装载购物车里的数据 &#125;访问: this.$store.state.shopCarArr mutations(数据管家)​ 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 注意: 在严格模式下, 不能直接让vue组件修改state里的属性值, 必须触发mutations里的方法, 来修改state里的属性值 注意: 这里的方法, 建议由actions来触发(异步), 如果只是单一的触发(同步)可以直接利用store.commit()来提交要变更的数据 参数: state, commitObj actions (异步操作)可以进行网络请求和一切的异步操作 Actions 提交的是 mutation，而不是直接变更state全局变量的值。 Actions 可以包含任意异步操作。 12&#x2F;&#x2F; 第一个参数是 store对象&#x2F;&#x2F; 第二个参数是 dispatch 传递过来的值 getters(计算属性)​ Vuex 允许我们在 store 中定义“getters”（可以认为是 store 的计算属性）。就像计算属性computed一样，getters 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 参数: 有个state modules​ 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters、甚至是嵌套子模块——从上至下进行同样方式的分割： 注意: modules 只是影响state里取值的方式 state.goodsModule.xxx属性 而actions和mutations以及getter正常访问即可 例如 123456export default new Vuex.Store(&#123; modules: &#123; shopModule, userModule &#125;&#125;) 使用速查 vuex核心 触发方式 备注 mutations $store.commit(事件名, 传参) actions $store.dispatch(actions名字, 传参)","categories":[],"tags":[]},{"title":"vue06","slug":"vue06","date":"2019-12-26T18:56:31.667Z","updated":"2019-10-21T13:04:04.339Z","comments":true,"path":"2019/12/27/vue06/","link":"","permalink":"http://yoursite.com/2019/12/27/vue06/","excerpt":"","text":"脚手架简介为了保证各项任务施工过程中顺利完整的进行, 而搭建的工作平台 (比如工地用的铁架子) 代码中体现: 下载了一套配置好的文件夹+文件+代码+插件的组合等 VueCli模块简介这是一个VueCli模块, 是一个工具模块, 它可以用来创建脚手架项目, 是一套文件夹+文件以及各种配置 内置了webpack-dev-server模块创建的 热更新服务器, 我们脚手架项目实际上是在本地服务器环境开发的 使用安装 npm install vue-cli -g 下载安装VueCli模块到全局 (只需要一次), 让计算机拥有vue命令 vue -V 检查vueCli脚手架版本, 如果显示版本号, 则代表安装成功 版本 VueCli2.x版本 -&gt; Webpack3.x版本 VueCli3.x版本-&gt; Webpack4.x版本 初始化项目 vue init webpack demo1 vue init 代表使用vueCli初始化一个项目 初始化项目使用webpack作为打包工具 demo1是我项目的名字, 也是文件夹的名字 效果: 会在网上下载一套固定的文件夹+文件的目录到我的demo1文件夹下 注意, 在哪里运行的命令, 就会在哪里新建一个demo1文件夹 初始化配置项 输入项 解释 Project name 项目的名字(不支持中文+特殊符号) Project description 项目的描述 Author 项目的作者 Vue build build打包依赖(默认即可)(无需按上下箭头选择) Install vue-router 是否安装路由(默认直接回车代表yes) Use ESLint to lint your code ESLint语法检查, 严格语法检查(空格, 回车, 缩进等都不能有一点点的错误) Set up unit tests 是否安装unit单元测试 Setup e2e tests with Nightwatch 自动化单元测试工作 Should we run npm install for you after the project has been created? 在项目创建完成后, 是否允许运行npm install命令 启动项目启动热更新服务器, 查看项目 &gt; npm run dev (参考package.json中命令) 项目默认运行在 http://localhost:8080 端口下 项目分析入口分析 项目配置入口: src/main.js 页面入口在: index.html 根组件: src/App.vue 路由入口: src/router/index.js 文件分析 文件夹/文件名 解析 demo1 脚手架项目文件夹名字 build 项目配置文件夹 —build.js 项目环境配置代码(发布打包时候用的配置入口) —check-versions.js 检查node和npm版本 —logo.png logo图标 —utils.js 一些封装的方法 —vue-loader.conf.js webpack对.vue文件的处理规则 —webpack.base.conf.js webpack基础配置(出入口) —webpack.dev.conf.js webpack开发环境配置(包含测试服务器环境) —webpack.prod.conf.js webpack发布环境配置(打包时的一些配置代码) —webpack.test.conf.js webpack集成的测试配置 config 环境变量的配置 —-dev.env.js 开发环境变量配置 —-index.js webpack相关的配置变量(开发网络请求接口代理在这里配置) —-prod.env.js 发布时的环境变量 —test.env.js 测试环境变量 dist 发布模式打包生成的文件夹(如果没有运行打包命令, 则此文件夹不会存在) —-static 打包的所有资源文件+静态资源文件都在这里 ———css 放置打包合成好的一个css文件的文件夹 ————–app.xxx.css 分离并压缩好的CSS文件 ——–js 放置打包后的js文件的文件夹 ————-app.xxx.js 你编写项目中所有你的JS源代码 ————manifest.xxx.js 打包后的缓存的配置代码 ————vendor.xxx.js 使用的第三方模块的源码 —-index.html 打包后的index.html项目页面入口(自动引入js和css等) node_modules 当前工程下载的第三方模块包(npm 下载和管理的模块 所在位置) src 源码目录 —-assets 静态资源文件(会被webpack构建打包的) ———logo.png logo图标 —-components vue公共组件文件夹 ———HelloWorld.vue 这就是一个组件文件(每定义一个组件都要有一个独立的.vue文件) —-router 路由文件夹 ———-index.js 具体路由配置代码 —-App.vue vue的组件根入口(路由展示的地方) —-main.js webpack打包的入口文件, 也是程序的入口文件, 加载各种公共组件/变量/配置 static 纯静态资源文件夹(不会被webpack构建打包) ..gitkeep 默认git无法提交空文件夹, 则添加这个文件后, 就可以上传这个文件夹了 test 测试相关资源文件夹 —-e2e e2e(端到端)测试文件夹 ——–custom-assertions 自定义断言配置文件夹 ————–elementCount.js 自定义断言Nightwatch一些变量 ——–specs 测试代码(用例)文件夹 ———-nightwatch.config.js nightwatch测试配置 ———runner.js 测试服务器配置 —-unit unit(单元测试)测试文件夹 ———specs 测试代码(用例) ————HelloWorld.spec.js 测试驱动配置 ——–.eslintrc eslint配置 ——-index.js 一些变量配置 ——karma.config.js karma测试配置 .bablerc ES6语法编译配置 (如果没有这个隐藏文件, 你的项目是不支持ES6语法的) .editorconfig 定义代码格式 .eslintignore eslint忽略检查配置文件 .eslintrc.js eslint配置文件 .gitignore git上传时需要忽略的文件的配置列表 .postcssrc.js postcss-loader模块的一个配置文件(加载CSS使用) index.html 开发环境时, 真正的网页的入口文件 package.json 项目基本信息(包括依赖包列表和自定义npm的指令等) package-lock.json 项目依赖包版本, 锁定文件 README.md 项目说明文件(使用的是markdown语法来编写的) 文件管理 建议components文件夹里, 放的都是复用的组件 建议pages/views文件夹里, 放的都是独立的页面(应用于路由中) 区分: 看这部分标签是否复用, 如果复用封装到单独.vue文件中, 放入components文件夹 项目打包部署​ 项目开发完毕, 需要把项目打包成一个独立的文件夹+文件, 放到服务器上, 而不是把整个本地开发环境的代码和配置放到发布的服务器上 打包之前, 需要在config/index.js/build对象中, 修改静态资源的相对路径 从 “/“, 修改成 “./“ 打包命令: &gt; npm run build 打包之后产出了一个dist文件夹, 把dist文件夹丢到服务器上, 即可完成部署 项目讲解@符号: 代表src的绝对路径 为什么不写扩展名: 因为在build/webpack.base.conf.js/35行 webpack打包配置已经写好了自动添加的扩展名 引用组件页面的.vue文件中, 想要使用其他.vue组件对象, 得先import 引入过来 使用静态资源12&lt;!-- 使用static里的静态资源, 是以打包后的相对路径为准 --&gt; &lt;img src=\"static/img/Koala.jpg\" alt=\"\"&gt;","categories":[],"tags":[]},{"title":"vue05","slug":"vue05","date":"2019-12-26T18:56:31.657Z","updated":"2019-10-18T13:49:45.319Z","comments":true,"path":"2019/12/27/vue05/","link":"","permalink":"http://yoursite.com/2019/12/27/vue05/","excerpt":"","text":"路由介绍​ Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌 ​ 在网页中, 切换掉当前网页中的某一部分, 进行不同页面的展示 ​ 文档: https://router.vuejs.org/zh/ 使用1. 引入VueRouter插件 (注意, 依赖于Vuejs, 所以要先引入Vuejs, 再引入VueRouter12&lt;script src=\"https://cdn.bootcss.com/vue/2.6.6/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 定义路由规则 123456789101112let routes = [ &#123; // path 代表当前路由的url path: \"/home\", // 当访问/home的路由时, 指定使用的组件对象 component: Home &#125;, &#123; path: \"/order\", component: Order &#125;]; 实例化VueRouter对象 123let router = new VueRouter(&#123; routes&#125;); 在当前Vue实例中使用路由功能 1234new Vue(&#123; el: \"#app\", router&#125;) 加入router-view组件, 用于展示路由不同页面 1&lt;router-view&gt;&lt;/router-view&gt; 工作过程​ 无需在Vue实例中, 声明components字段注册组件了, 因为当前路由列表里, 已经配置好了对应的组件​ 在地址栏的#后面, 当你访问对应path路径时, 就会把对应的component组件渲染到对应的router-view上 注意: url中从#开始往后, 就是要匹配的路由的path路径, 路由默认的路径是 / 注意: 为了在对象中, 实现对象的简化写法, routes 和router变量要固定 路由切换标签切换a标签1&lt;a href=\"#/home\"&gt;去首页&lt;/a&gt; 原理: 切换url的锚路径, 来达到切换路由的目的 router-link组件123&lt;router-link to=\"/home\"&gt;去首页&lt;/router-link&gt;// 还可以设置激活时的高亮样式&lt;router-link to=\"/home\" active-class=\"active_title\"&gt;去首页&lt;/router-link&gt; 联系&amp;区别 router-link 其实还是a标签, 但是会自动选择使用哪种路由方式 router-link 还会对选中的a标签, 动态添加class类名: router-link-exact-active : 配置当链接被精确匹配的时候应该激活的 class router-link-active : 链接激活时使用的 CSS 类名 (你不指定属性active-class时, 默认会添加此class类名) 路由重定向1234&#123; path: \"*\", // 上面的所有路径, 都没有命中, 则执行这里, *代表一切字符串 redirect: \"/home\" // 重定向到\"/home\"的路由下(修改#/路径为 /home)&#125; JS切换方式1123// 利用$router下的push方法, 进行路由页面的切换this.$router.push(\"/home\");this.$router.push(&#123;path: \"/home\"&#125;); 方式21this.$router.replace(&#123;path: \"/order\"&#125;) 区别replace: 1如果从A -&gt; B -&gt; &#x2F;order, 相当于替换了B路径的路由, 在你返回时, 只能返回到上一次的上一次路由页A push: 1正常返回到上一层的路由页, 相当于在history对象(window的)中加入走过的路径, 能够正常的回退&#x2F;前进 用到Vue实例中的2个属性对象 $route 123456789fullPath: \"/home\"hash: \"\"matched: [&#123;…&#125;]meta: &#123;&#125;name: undefinedparams: &#123;&#125;path: \"/home\"query: &#123;&#125;redirectedFrom: \"/\" $router (它包含了$route, $router.currentRoute就是$route的东西) 路由传参a标签传参向跳转的路由内传参1234567891011&#123; // 1. 在path路径上制定变量名, /:代表这段路径, 是一个参数的数据 // 例如: /detail/红楼梦/59 // path: /detail/:bookName/:price (bookName -&gt; 红楼梦, price -&gt; 59) path: \"/detail/:bookName\", component: DetailCom&#125;&lt;!-- 2. 在需要传值的地方, 进行传值, 如果要使用JS的东西, 需要:to--&gt;&lt;router-link :to=`/detail/$&#123;obj['name']&#125;`&gt;&#123;&#123;obj['name']&#125;&#125;&lt;/router-link&gt;&lt;!-- 3. 取在url上传递的参数, 使用$route.params, 注意取出来的是一个对象结构 --&gt; &lt;p&gt;&#123;&#123;this.$route.params['bookName']&#125;&#125;&lt;/p&gt; js切换传参path+query123456789// 1. 跳转路由, 传递参数 this.$router.push(&#123; path: \"/detail\", query: &#123; bookName: bName &#125; &#125;)// 2. 组件内接受并使用&lt;p&gt;&#123;&#123;this.$route.query['bookName']&#125;&#125;&lt;/p&gt; name+params (了解) 1234567891011121314151617// 1. 需要在路由配置里加入name选项let routes = [ &#123; path: \"/detail\", name: \"detail\", component: DetailCom &#125; ]// 2. 跳转传参this.$router.push(&#123; name: \"detail\", params: &#123; bookName: bName &#125; &#125;)// 3. 组件内取值&lt;p&gt;&#123;&#123;this.$route.params['bookName']&#125;&#125;&lt;/p&gt; 注意: 如果组件已经存在于页面上, 则跳转路由传参, 不会重新更新params的值 嵌套路由 在路由列表中, 配置children: [], 再设置其中的子路由配置项 在子组件中使用, 来加载子路由页面 注意: 配置路由列表, 子路由的path, 不要加 / 注意: 在跳转/切换时, 路由的path要从根/开始写. 例如: /second/two/hello ref属性 声明ref: 获取标签: this.$refs.myInput; 面试题路由模式hash模式​ 当你使用hash模式时, URL在#后面设置路由的访问, 但是如果页面上有锚点连接, 会冲突 ​ http://localhost:63342/web0415/第四阶段/day07_vue05/10_路由嵌套.html#/second/two history模式​ 当你使用 history 模式时，URL 就像正常的 url，例如 http://yoursite.com/user/id，也好看！","categories":[],"tags":[]},{"title":"vue04","slug":"vue04","date":"2019-12-26T18:56:31.657Z","updated":"2019-10-18T00:31:53.474Z","comments":true,"path":"2019/12/27/vue04/","link":"","permalink":"http://yoursite.com/2019/12/27/vue04/","excerpt":"","text":"Vue生命周期介绍图解: https://cn.vuejs.org/images/lifecycle.png Vue的生命周期方法, 又叫做生命周期钩子函数, 钩子函数: C#语言里的叫法, 它其实就是构造函数(constructor), 对象出生时触发, 对应的叫: 析构函数 (对象释放前触发) 钩子函数beforeCreate​ Vue实例化之后, 数据和事件加载之前调用 created​ 数据观察和事件以及属性, 初始化完毕, 但是页面上还没有挂载任何标签节点, 一般网络请求写在这里 beforeMount​ 判断el选项, 如果有, 则再判断有无template选项, 如果没有template选项, 则认为el中的标签节点为它的模板标签, 然后在挂载DOM之前触发此方法 mounted​ 真正的el标签内被虚拟DOM已经替换掉, 已经挂载 注意: mounted不能保证所有的子组件都已经被挂载成功才触发, 如果想要确保所有组件都被挂载需要使用this.$nextTick(回调函数) beforeUpdate​ 数据更新时调用, 但是在DOM页面更新前触发 updated​ 页面上的DOM已经更新完毕 activated​ keep-alive属性的组件激活时调用。 deactivated​ keep-alive属性组件被停用时触发 beforeDestroy​ 实例在销毁之前调用 destroyed​ 实例销毁后调用 Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 errorCaptured​ 捕获子组件的错误信息 注意只有在vuejs2.5+版本后才可以使用这个方法 v-for的高级用法循环对象12345&lt;!-- item 代表的是 每对键值对中的, 值--&gt;&lt;!-- key 代表的是, 每对键值对中的, 键--&gt;&lt;!-- index 代表的是, 每个键值对中的, 索引--&gt; v-for=\"(value, key, index) in object\" 循环数字12&lt;!-- item 从1 开始, index 索引 从0开始 --&gt;v-for=\"(n,index) in 10\" 嵌套循环1234&lt;li v-for=\"(obj, index) in arr\" :key=\"index\"&gt; &lt;p&gt;&#123;&#123;obj['name']&#125;&#125;&lt;/p&gt; &lt;span v-for=\"(item, ind) in obj['grade']\"&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;&lt;/li&gt; 更新检测Vue是响应式数据绑定, 只有当数据发生变化并且被检测到的时候, 才会触发页面的更新 数组检测例如: 12arr: [1, 2, 3, 4]this.arr[0] = 10; // 虽然arr被修改了, 但是它是非变异方式, 所以页面无法自动更新 解决方式: 让arr的值重新被覆盖, 可以触发变异方式, 更新页面 …叫做扩展运算符 123let myArr = [...this.arr];myArr[0] = 1000;this.arr = myArr; 使用Vue.set()方法即可触发数组更新 参数: 数组对象, 索引, 要赋予的值 可触发 reverse() pop() push() shift() unshift() splice() 像这类方法可以直接改变原始数组的, 就会触发变异方式, 更新页面 不可触发 concat() 连接多个数组, 返回一个全新的数组 filter() 检测数值元素，并返回符合条件所有元素的数组。 (参数是一个回调函数, 当函数返回值是true, 则保留当前元素) forEach() 数组每个元素都执行一次回调函数 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 slice() 截取并返回一个新数组 Vue对数组的方法分为 变异方法(可触发) / 非变异方法(不可触发), 只有在使用变异方法时, 页面上的数组才会被重新加载 注意: 需要把接收到的全新的数组, 覆盖给页面使用的数组变量, 才可以触发更新 对象检测1this.obj['address'] = \"地球上\"; // 这种方式无法触发变异方式 解决方式: 深拷贝, 并且覆盖原有对象, 使页面更新 123let obj = &#123;...this.obj&#125;;obj['address'] = \"地球上\";this.obj = obj; Vue.set() 参数: 对象, 键名, 要赋予的值, 但是注意他不能和上面那行共存 动画使用文档: https://cn.vuejs.org/v2/guide/transitions.html transition组件, 是vue官方的内置组件, 集成了进入/离开过渡动画 原理: 在运行期间, 动态给标签设置class类名, 但是具体的过渡效果的样式需要我们自己写 触发的条件: 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 使用方式: 利用transition标签, 夹住要做过渡动画的标签 指定name名字 (不指定就使用默认name为v), 注意应用于自动生成class类名的前缀上. 对transition内的根标签, 设置条件渲染/展示渲染/动态组件/代码 根据业务逻辑来切换标签的出现/隐藏, 让transition动态添加/移除class类名 对class类名, 设置具体的样式(例如透明度/颜色/其他样式) 过渡类名: 在执行出现/隐藏时, 分别会添加3个class类名, 前三个隐藏-&gt;出现 后三个出现-&gt;隐藏 v-enter: 定义进入过渡的开始状态。 (开始) v-enter-active：定义进入过渡生效时的状态。这个类可以被用来定义进入过渡的过程时间 (过程) v-enter-to: 2.1.8+ 定义进入过渡的结束状态。 (结束定型) v-leave: 定义离开过渡的开始状态。 v-leave-active：定义离开过渡生效时的状态。 v-leave-to: 2.1.8+ 定义离开过渡的结束状态。 注意: 以上自动添加的class类名, 会在动画结束之后, 全部移除掉 例如: 123456789101112/*enter -&gt; enter to leave -&gt; leave-to*/ .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; .fade-enter-to, .fade-leave &#123; opacity: 1; &#125; .fade-enter-active, .fade-leave-active &#123; transition: all 0.3s; &#125; 注意: 多个标签, 同时做进入和出去的动画, 会有问题 注意: transition 组件内, 只能有一个根标签, 如果有多个根标签, 则用transition-group(需要给每个标签指定一个key属性 如果不用transition-group, 可以使用动态组件 自定义指令学过的指令 v-bind v-on v-for v-if v-else v-show v-model v-once 分类全局指令123456789Vue.directive('change', &#123; // 当被绑定的元素插入到 DOM 中时…… bind: function(el, binding) &#123; el.innerHTML = binding.value; &#125;, update: function (el, binding) &#123; el.innerHTML = binding.value; &#125; &#125;); 本地指令1234567891011// 本地指令directives: &#123; change: &#123; bind: function(el, binding) &#123; el.innerHTML = binding.value; &#125;, update: function (el, binding) &#123; el.innerHTML = binding.value; &#125; &#125;&#125; 指令_钩子函数每个指令都有以下方法 bind: 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted: 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在指令的标签更新时调用(多次), 指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的指令更新 (详细的钩子函数参数见下)。 修饰符 .lazy 只有在input输入框发生blur时才触发 (把value的值绑定到vue变量上) .trim 将用户输入的前后的空格去掉, 再绑定给Vue的变量 .number 将用户输入的字符串转换成number, 再绑定给Vuejs的变量","categories":[],"tags":[]},{"title":"vue03","slug":"vue03","date":"2019-12-26T18:56:31.647Z","updated":"2019-10-17T01:47:28.155Z","comments":true,"path":"2019/12/27/vue03/","link":"","permalink":"http://yoursite.com/2019/12/27/vue03/","excerpt":"","text":"组件概念​ 组件其实就是一堆可服用的标签实例, 且带有一个名字, 而且组件分为全局组件和本地组件 ​ 每个组件都有自己的作用域, 都是一个独立存在的个体 分类全局组件1234567891011&lt;child-com&gt;&lt;/child-com&gt;// buy-item代表组件名(自己定义)// 对象代表组件的配置项Vue.component(\"child-com\", &#123; // 组件内的data, 必须是一个函数返回对象的结构 data () &#123; &#125;, // 组件包含的标签 (只能有一个根标签) template: ``&#125;) 注意, 这里的child-com即是组件名(自定义标签名) , 不要跟现有的标签重名 注意, 全局组件, 可以应用在任意一个角落 本地组件1234567891011121314151617181920// 3. 使用组件&lt;child-com&gt;&lt;/child-com&gt;&lt;div is=\"childCom\"&gt;&lt;/div&gt;// 1. 定义组件let childCom = &#123; template: ` &lt;div&gt;局部组件&#123;&#123;num&#125;&#125;&lt;/div&gt; `, data()&#123; return &#123; num: 10 &#125; &#125;&#125;// 2. 注册组件components: &#123; childCom&#125; 注意: 只在当前vue实例/当前.vue文件中可以使用 / 需要引入后使用 组件内用方法 注意组件内的方法只能在当前方法中使用 组件传值父-&gt;子在使用组件的时候, 向组件内的props变量, 传递数据 1&lt;buy-item :u-name=\"userName\"&gt;&lt;/buy-item&gt; 在自定义组件中, 声明props属性, 用户接受外部给我传递的数据 123props: &#123; uName: String&#125; 在组件标签上, 使用接收到的数据 1template: `&lt;p&gt;&#123;&#123;uName&#125;&#125;&lt;/p&gt;` 组件内_自定义事件系统的事件: @click @mouseout @mouseover @keyup @keydown @input @change …. 以上都是系统的事件 1&lt;my-item @ldx-click=\"myClickFn\"&gt;&lt;/my-item&gt; ldxclick: 是自己起的自定义事件名 myClickFn: 当ldxclick事件, 被触发时, 要执行的方法 子-&gt;父在自定义事件的基础上, 在组件内触发并且传值出去 1this.$emit(\"ldx-click\", ++this.num); 注意: 组件内一般只负责数据的展示, 所有的业务逻辑最好都传回给页面去做 props验证有时我们封装自己的组件库时, 想要告诉使用你组件的人, 传入参数必须是xxx类型等约束, 所以使用props验证规则 null 任意类型 String 字符串类型 [String, Number] 字符串/数值类型 { type: String, required: true } 必须传, 而且是字符串类型 { type: Number, default: 100} 数值类型, 如果不传, 则使用默认值100 {type: Array, default () {return []} } 数组类型, 如果不传, 则使用默认值 [] validator: function (value) { return value &gt; 10 } 自定义验证规则 (返回true则通过验证规则) props: 变量 对应的是 类型, 同时使用default字段, 来给默认值 data: 变量 对应的是 默认值(初始值) 注意: 引用数据类型Object/Array, 默认值必须使用函数返回 注意: 如果外面没有给props里变量传值, 则变量使用默认的值 特殊用法 table&gt;tr中不能直接使用组件, 需要在tr的is属性指定组件名 select&gt; 也不能封装options组件, 需要在option的is属性指定组件名 使用组件方式 &lt;组件名&gt;&lt;/组件名&gt; 动态组件 把组件的名字, 使用Vuejs变量带代表, 修改变量为各个组件名字, 即可实现组件的切换 组件的插槽当相似的组件, 某1-2个标签不同时, 我们可以留一个slot标签, 让外部传入标签到组件中 使用技巧 父-&gt;子: 传值用props 子-&gt;父: 用自定义事件, 带值 组件之间类似, 只差1-2个标签, 用插槽 组件之间相差很大, 而且要根据数据来切换不同组件使用, 则用动态组件 注意事项 components里key值/全局组件第一个参数, 就是在html中使用的组件标签名字(注意html中使用时要换成-连接) 组件内不要写网络请求/太多的逻辑代码, 组件只负责数据展示, 逻辑参数传回页面处理","categories":[],"tags":[]},{"title":"vue01","slug":"vue01","date":"2019-12-26T18:56:31.627Z","updated":"2019-10-14T13:10:47.817Z","comments":true,"path":"2019/12/27/vue01/","link":"","permalink":"http://yoursite.com/2019/12/27/vue01/","excerpt":"","text":"Vue阶段要学习的内容 Vuejs 基础语法 Vue-router (前端路由组件) Vuex (全局状态管理器) axios (可用在前端/Node的请求模块) Vue-cli2 (vue2.x) 脚手架模板 组件库的学习 简介(What)​ 它是一个渐进式的前端框架, 底层还是封装的原生JS ​ 渐进式: 由底向上逐级开发组件, 增量开发, 构成我们的应用 为什么学?(Why)​ Vuejs的速度一目了然, 容错性很高. 成吨的提高你的开发效率, 极大减少了你操作DOM的动作, 只需要关系数据和视图即可 ​ 原生Javascript: 123456789101112&lt;body&gt; &lt;ul id=\"myUl\"&gt;&lt;/ul&gt; &lt;script&gt; let arr = [\"春天\", \"夏天\", \"秋天\", \"冬天\"]; let myUl = document.getElementById(\"myUl\"); for (let i = 0; i &lt; arr.length; i++)&#123; let theLi = document.createElement(\"li\"); theLi.innerHTML = arr[i]; myUl.appendChild(theLi); &#125; &lt;/script&gt;&lt;/body&gt; ​ Vue实现同样效果: 123456789&lt;div id=\"app\"&gt; &lt;ul&gt;&lt;li v-for=\"item in arr\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: \"#app\", data: &#123;arr: [\"春天\", \"夏天\", \"秋天\", \"冬天\"]&#125; &#125;)&lt;/script&gt; ​ 原生js好比锯条, jq好比是带把手的锯条, vuejs电锯 怎么学?(How) 要有html+css+javascript的基础 以及Vuejs的基础语法 (不建议上来就用VueCli脚手架) NodeJS+Webpack的基础 VueJS路由学习 VueCli脚手架的学习和使用 (熟悉VueCli里的各项配置) Vuex+脚手架里使用路由+网络请求库+组件库的学习 VueJS注意事项 不兼容IE8及以下IE浏览器 建议安装vue的devtool工具, 帮助你进行调试代码 必须是vuejs编写的代码, 才可以在控制台使用vue调试工具 安装devTool工具 下载: 官网(https://cn.vuejs.org/) -&gt; 生态系统 -&gt; devTool工具 我们下载的是Google Chrome浏览器的插件 -&gt; 打开谷歌浏览器 -&gt; 更多工具 -&gt; 扩展程序 打开开发者模式, 把下载好的插件文件夹 -&gt; 拖拽扔进去即可完成安装 注意: 插件的文件夹不要删除/也不要随意挪动 使用VueJS 引入vuejs的js文件 1&lt;script src=\"https://cdn.bootcss.com/vue/2.6.6/vue.js\"&gt;&lt;/script&gt; 声明根节点标签, 包裹着的都是Vuejs代码, 注意不能以html/body为根标签 1&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt; 实例化Vue对象 123new Vue(&#123; el: \"#app\", // 告诉vue实例, 从id叫app的标签开始, 内部都是你vue的代码&#125;) 声明式渲染​ 它就是vuejs里最独特的使用方式, 可以在html中直接书写JS的变量/表达式 ​ js表达式: 由变量/常量+运算符 组成 1&lt;p&gt;&#123;&#123;表达式&#125;&#125;&lt;&#x2F;p&gt; 123456new Vue(&#123; el: \"#app\", data : &#123; // data里都是声明的变量 message: \"欢迎来到vuejs的世界\" //无需var/let, 直接书写即可! &#125;&#125;) ​ 注意, 声明式渲染中, 可以写入表达式代码(包括判断/运算/条件运算符)等 ​ 例如: &lt;p&gt;{{ message }}&lt;/p&gt; &lt;p&gt;{{ 10 + 5 }}&lt;/p&gt; &lt;p&gt;{{ grade === 10 ? '等于' : '不等于' }}&lt;/p&gt; &lt;p&gt;{{ grade > 9 }}&lt;/p&gt;指令​ v- 开头的, 叫做 指令, 作用: 给标签扩展更多的功能, 因为你的属性被vue的指令修饰了, 说明现在你用的是vue的东西, 所以可以直接使用, 无需再加双大括号修饰 v-bind​ 给标签自带的属性, 设置一个变量的值, 12&lt;p v-bind:title=\"pTitle\"&gt;我是个可怜, 无助, 能吃的p标签&lt;/p&gt;&lt;img :src=\"imgSrc\" alt=\"\" /&gt; v-on​ 给标签绑定事件, 注意后面的地方直接跟方法名, 如果没有参数, 则无需写小括号 1234v-on:click=\"btn\"@click=\"btn2\" // 事件简化写法用@// 方法要写在new Vue() 的methods:中 v-if​ 控制标签的出现和隐藏, 用于控制标签的 出现/隐藏 如果传true则当前标签+所有子标签都出现 ​ 如果传false, 则都不会出现, 但是如果有对应的v-else会显示v-else的标签 v-else​ v-else不能单独出现, 必须配合对应的v-if使用 v-show​ 跟v-if的效果一样, 唯一的区别是: ​ v-if 传false 时, 不会在DOM上加载这个标签 ​ v-show 传false 时, 会在DOM上加载这个标签(利用display:none;的方式隐藏 所以用v-if和v-show取决于标签是否要频繁的切换, 如果需要则使用v-show, 效率高, 特别是包含子标签特别多的时候 v-for​ 用于根据数据, 循环生成标签, 在指令里用的是最多的 ​ item: 临时变量, 每次循环, 获取的是数组里每一项的值 ​ in关键字(必须) ​ arr 代表的vue里声明的变量(数组) ​ index: 临时变量, 代表下角标的使用 ​ 注意1: 每个循环的标签, 需要给一个独立(不重复的)key属性的值, 用来标识唯一性, 用于部分刷新和重载数据 ​ 注意2: v-for使用位置: 确定让哪个标签循环铺设, 就在哪个标签身上写v-for ​ 注意3: v-for里的临时变量, 只能在当前标签/子标签内使用, 不能在兄弟标签上使用 v-model​ v-model主要应用于表单标签上, value属性的绑定, 实现页面标签的value值和Vuejs变量的双向绑定 (推荐使用v-model), 页面改变表单的值, 会同步给vuejs里的变量 注意: 只有input和textarea以及select 等表单, 有v-model, 用v-model来给表单绑定值 ​ 例如: 输入框/密码框/多选/下拉/单选/textarea ​ 注意: 多选框的v-model必须是一个数组类型 v-model, 实际上绑定的就是value属性 v-once​ v-once修饰的标签, 只有在网页打开的第一次加载完, 以后就不会在受变量变化而影响 事件详解​ 在事件/属性后面.xxx 叫做修饰符, 修饰符一般都有额外的功能 @click.stop 阻止事件冒泡 @click.prevent 阻止默认事件 @click.self 只能由标签自身触发 @click.once 程序运行期间只能执行一次 @click=”btn6(myArg)” 事件传参, 如果是字符串, 请用单引号 注意: 如果传参, 再使用(), 如果不传, 可以省略()不写, 如果传实践对象, 要使用$event 双向数据绑定原理 页面-&gt;数据, 借助 oninput事件 数据-&gt;页面, 借助Object.defineProperty() 监听一个对象的属性值的变化 12345678910111213141516171819202122232425let temp = \"\"; // 临时存储值 function change(ev)&#123; data.message = ev.target.value; // 获取输入框里最新的值 &#125; let data = &#123; // 准备类似data里的数据 message: \"\" &#125;; // 参数1: 监听的对象, 参数2: 监听对象里的属性名, 参数3: 固定写法 Object.defineProperty(data, \"message\", &#123; // 当你获取data对象里的message属性值的时候, 触发get方法 // 不要在get方法里直接提取data.message的值, 会造成递归调用卡死. get () &#123; // return到你 写data.message的地方 return temp; &#125;, // data.message = xxx 赋值的时候, 才会触发 set (val) &#123; // 更新页面(所有跟message变量相关的界面) document.getElementById(\"myP\").innerHTML = val; document.getElementById(\"myInput\").value = val; // 更新message的值 temp = val; &#125; &#125;); 其他资料​ Vuejs官网: https://cn.vuejs.org/","categories":[],"tags":[]},{"title":"vue02","slug":"vue02","date":"2019-12-26T18:56:31.627Z","updated":"2019-10-15T12:48:11.577Z","comments":true,"path":"2019/12/27/vue02/","link":"","permalink":"http://yoursite.com/2019/12/27/vue02/","excerpt":"","text":"计算属性Computed作用​ 依靠其他的一些变量的值, 来计算出我想要的结果, 并且赋予给计算属性的变量直接使用 使用​ computed : {} 中声明计算属性变量, 注意每个属性都要有一个返回值 ​ 计算属性, 会在函数内, 当引用的变量, 发生变化时, 自动执行函数里的对应代码, 然后返回新的结果 注意 里面的属性和data不能重复 (重点) 计算属性的, 变量 可以直接在页面使用 区别: data里只能写默认值, 计算属性可以根据其他的值计算一个最终结果返回 可以在一个计算属性内, 使用另外一个计算属性的值 set/get方法 当需要给计算属性赋值的时候, 使用set方法, 而且要注意, 不要产生了递归 当你提取计算属性值的时候, 触发get方法, 或者在你修改get方法里引用的变量时, 也会触发 不是必须得声明set/get方法, 只需要需求有修改计算属性时, 才需要声明set和get方法 代码示例12345678910111213141516computed :&#123; sumPrice () &#123; return (this.count * this.everyPrice).toFixed(2); &#125;, dSumPrice () &#123; return (this.sumPrice * this.discount).toFixed(2); &#125;, chaPrice: &#123; set() &#123; &#125;, get() &#123; &#125; &#125;&#125; 监听属性watch作用​ 用于监听data/computed属性的值的变化, 一旦监听的属性值被改变, 则触发对应的watch方法 使用​ watch: {} 直接写你想监听的属性名 以及对应方法体即可 动态绑定class 写法一: 结构 :class={class选择器名: 布尔值}, 当布尔值为true时, 把key赋予给class属性 1:class=\"&#123;active: isActive&#125;\" 写法二: 结构 :class={选择器1: 布尔值, 选择器2: !布尔值}, 可以进行2个对立的样式选择, 此对象也可以用vue变量来代表 1:class&#x3D;&quot;&#123;success: isOk, error: !isOk&#125;&quot; 写法三: 混用结构: 可以同时使用原生的和Vue的 1:class&#x3D;&quot;myClass&quot; class&#x3D;&quot;error&quot; 动态绑定style 写法一: 结构 :style=”{CSS属性名: 对应值}”, 任何东西都可以用vue的变量代替, 多对就接着逗号写 1:style&#x3D;&quot;&#123;backgroundColor: &#39;red&#39;&#125;&quot; 过滤器使用作用​ 传入参数后, 经过处理后, 返回处理后的结果 使用本地过滤器1234567891011 filters: &#123; checkUserName (val) &#123; if (val.length &gt; 6)&#123; return 'success'; &#125; else if (val.length &gt; 0) &#123; return 'error'; &#125; &#125; &#125;v-model=\"userName\":class=\"userName | checkUserName\" 本地过滤器(只能在当前组件/实例中使用) 全局过滤器全局过滤器, 在整个项目中, 任意位置都可以使用 1234567Vue.filter(\"checkPassWord\", (val) =&gt; &#123; if (val.length &gt; 8)&#123; return 'success'; &#125; else if (val.length &gt; 0) &#123; return 'error'; &#125; &#125;) 注意: 非常重要: 要注意顺序, 全局性的东西, 要写在new Vue() 之前 注意: 如果全局过滤器和本地过滤器重名了, 执行本地的. (就近原则) 注意: 过滤器只能使用在声明式渲染的大括号内, 或者是v-bind: 指令中 面试题安全数问: 为什么0.1+0.2不等于0.3 ​ 在Javascript中, 安全数字的范围是2的53次幂-1 ​ 进行算数运算时, 会把10进制 -&gt; 2进制, 然后进行计算, 当数字转换成二进制以后, 如果大于2的53次幂位以后, 再进行运算可能造成精度丢失 举例: 9999999999999999999 + 100 举例: 9007199254740992 + 1 举例: 0.7 * 180 解决方式: 保留小数位.toFixed()后再进行比较","categories":[],"tags":[]},{"title":"vue08_axios使用","slug":"vue08_axios使用","date":"2019-12-26T18:56:31.357Z","updated":"2019-10-24T08:06:12.586Z","comments":true,"path":"2019/12/27/vue08_axios使用/","link":"","permalink":"http://yoursite.com/2019/12/27/vue08_axios%E4%BD%BF%E7%94%A8/","excerpt":"","text":"路由守卫某个路由监听 beforeEnter() 的使用, 某一个 123456789101112&#123; path: \"/home\", name: \"Home\", component: Home, // 当路由访问/home时, 跳转路由之前, 触发此方法 beforeEnter(to, from, next) &#123; // to: 要跳转的路由的信息 // from: 从哪个路由跳过来的信息 // next: 是否继续执行下一个中间件(需要手动调用, 才会让路由跳转) next(); &#125; &#125; 全局路由监听 beforeEach()的使用, 全局路由监听使用 123456789101112131415161718// 全局路由监听(导航/路由守卫)// 每当路由改变时, 就会触发此方法// 重定向时, 如果to和from相同时, 不会触发beforeEachtheRouter.beforeEach((to, from, next) =&gt; &#123; // 1. 用户登录的状态(后台/localStorage/Cookie/SessionStorage) if (localStorage['userStatus'] || to.path === \"/login\") &#123; // 已登录 if (localStorage['userStatus'] &amp;&amp; to.path === \"/login\") &#123; // 已经登录了, 还想去登录页, 直接强制跳转回首页 next(\"/home\"); &#125; else &#123; next(); &#125; &#125; else &#123; next(\"/login\"); // 未登录时, 你只能被重定向到登录页 &#125; // next(); // 执行下面的路由代码&#125;); axios简介axios 是一个基于Promise 用于浏览器和 nodejs 的 网络请求的模块 使用 下载axios模块到工程中, 命令 npm i axios 热更新服务器配置请求接口12在webpack.dev.conf.js中devServer对象中, 添加before(server)&#123;&#125; 本地数据例1: 1234app.get(\"/api/getGoodsList\", (req, res) =&gt; &#123; // 当前端Ajax请求/api/getGoodsList就会触发此函数执行 res.send([\"香蕉\", \"苹果\", \"桃子\", \"鸭梨\"]); &#125;); 例2: 1234const newsObj &#x3D; require(&quot;..&#x2F;data&#x2F;news&quot;) &#x2F;&#x2F; 引入本地json文件数据 app.get(&quot;&#x2F;api&#x2F;getNews&quot;, (req, res) &#x3D;&gt; &#123; res.send(newsObj); &#125;) 作为代理服务器,12345678910// 我们自己的前端 -&gt; /api/163news -&gt; 后端请求网易新闻的接口 -&gt; 拿回数据处理后 -&gt; 返回给自己前端使用app.post(\"/api/163news\", (req, res) =&gt; &#123; axios.get(\"http://c.m.163.com/nc/article/headline/T1348647853363/0-40.html\").then(responseText =&gt; &#123; let queryObj = req.body; let start = queryObj['start'] * 1; let end = queryObj['end'] * 1; res.send(responseText['data']['T1348647853363'].slice(start, end)); &#125;)&#125;) 代理服务器配置(常用)原理和代理服务器里写, 转发的axios网路请求一样, 只不过, 配置只需要配置一次, 一劳永逸 配置如下: demo2 &gt; config &gt; index.js中 1234567proxyTable: &#123; // 用来配置服务器, 代理接口转发规则 '/nc': &#123; target: 'http://c.m.163.com', // 当服务器收到/nc开头的请求接口时, 会把请求的url由http://localhost:8080/nc/getTitle/xxxxxx变成 // http://c.m.163.com/nc/getTitle/xxxxxx changeOrigin: true, // 是否修改域名 &#125; &#125;, 特点 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 多页面 // 1. 新建pages/love/love.js + Love.vue + love.html// 2. 在webpack.base.conf.js 基础配置:// love: ‘./src/pages/love/love.js’// 3. 在webpack.dev.conf.js 配置/* new HtmlWebpackPlugin({filename: ‘love.html’,template: ‘./src/pages/love/love.html’, // 注意路径inject: true,chunks: [‘manifest’, ‘vendor’, ‘love’]}), /// 4. wepback.prod.conf.js/ new HtmlWebpackPlugin({filename: ‘love.html’,template: ‘./src/pages/love/love.html’,inject: true,minify: {removeComments: true,collapseWhitespace: true,removeAttributeQuotes: true// more options:// https://github.com/kangax/html-minifier#options-quick-reference},// necessary to consistently work with multiple chunks via CommonsChunkPluginchunksSortMode: ‘dependency’,chunks: [‘manifest’,’vendor’,’love’]}), */","categories":[],"tags":[]}]}